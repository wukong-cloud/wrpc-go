/*
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package main

import (
    "fmt"
    "strings"

    "google.golang.org/protobuf/compiler/protogen"
)

const (
    contextPackage   = protogen.GoImportPath("context")
    fmtPath          = protogen.GoImportPath("fmt")
    wrpcgoPackage    = protogen.GoImportPath("github.com/wukong-cloud/wrpc-go")
    protoPackage     = protogen.GoImportPath("github.com/golang/protobuf/proto")
)

// generateFile generates a _tars.pb.go file containing wrpc service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
    if len(file.Services) == 0 {
        return nil
    }
    filename := file.GeneratedFilenamePrefix + "_wrpc.pb.go"
    g := gen.NewGeneratedFile(filename, file.GoImportPath)
    g.P("// Code generated by protoc-gen-go-wrpc DO NOT EDIT.")
    g.P("// versions:")
    g.P("// - protoc-gen-go-wrpc v", version)
    g.P("// - protoc             ", protocVersion(gen))
    if file.Proto.GetOptions().GetDeprecated() {
        g.P("// ", file.Desc.Path(), " is a deprecated file.")
    } else {
        g.P("// source: ", file.Desc.Path())
    }
    g.P()
    g.P("package ", file.GoPackageName)
    g.P()
    generateFileContent(gen, file, g)
    return g
}

func protocVersion(gen *protogen.Plugin) string {
    v := gen.Request.GetCompilerVersion()
    if v == nil {
        return "(unknown)"
    }
    var suffix string
    if s := v.GetSuffix(); s != "" {
        suffix = "-" + s
    }
    return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

// upperFirstLatter make the fisrt charater of given string  upper class
func upperFirstLatter(s string) string {
    if len(s) == 0 {
        return ""
    }
    if len(s) == 1 {
        return strings.ToUpper(string(s[0]))
    }
    return strings.ToUpper(string(s[0])) + s[1:]
}

func lowerFirstLatter(s string) string {
    if len(s) == 0 {
        return ""
    }
    if len(s) == 1 {
        return strings.ToLower(string(s[0]))
    }
    return strings.ToLower(string(s[0])) + s[1:]
}

// generateFileContent generates the TarsGo service definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
    if len(file.Services) == 0 {
        return
    }

    for _, service := range file.Services {
        genService(gen, file, g, service)
    }
}

func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {

    generateService(g, service)

    generateDispatcher(g, service)

    generateClient(g, service)
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) {
    g.P("type ", service.GoName, "Server interface {")
    for _, method := range service.Methods {
        g.P(method.GoName, "(", contextPackage.Ident("Context"), ", *", method.Input.GoIdent.GoName, ") (*", method.Output.GoIdent.GoName, ", error)")
    }
    g.P("}")
    g.P()

    g.P("type Nop", service.GoName, "ServerImpl struct{}")
    g.P()
    for _, method := range service.Methods {
        g.P("func (_ *Nop", service.GoName, "ServerImpl)", method.GoName, "(ctx ", contextPackage.Ident("Context"), ", req *", method.Input.GoIdent.GoName, ") (*", method.Output.GoIdent.GoName, ", error) {")
        g.P("return nil, ", fmtPath.Ident("Errorf"), "(\"method ", method.GoName, " not implemented\")")
        g.P("}")
        g.P()
    }
    g.P("func New", service.GoName, "Server(name string, impl ", service.GoName, "Server, opts ...", wrpcgoPackage.Ident("ServerOption") ,") ", wrpcgoPackage.Ident("Server"), " {")
    g.P("return ", wrpcgoPackage.Ident("NewRPCServer"), "(name, impl, ", service.GoName, "ServerDispatcher, opts...)")
    g.P("}")
    g.P()
}

func generateDispatcher(g *protogen.GeneratedFile, service *protogen.Service) {
    g.P("func ", service.GoName, "ServerDispatcher(ctx ", contextPackage.Ident("Context"), ", impl interface{}, req *", wrpcgoPackage.Ident("Request"), ", enc ", wrpcgoPackage.Ident("Encoder"), ") ([]byte, error) {")
    g.P("obj, ok := impl.(", service.GoName, "Server)")
    g.P("if !ok {")
    g.P("return nil, ", fmtPath.Ident("Errorf"), "(\"method %s not found\", req.Method)")
    g.P("}")
    g.P("_ = obj")
    g.P("switch req.Method {")
    for _, method := range service.Methods {
        g.P("case \"", method.GoName, "\":")
        g.P("input := ", method.Input.GoIdent.GoName, "{}")
        g.P("if err := enc.Decode(req.Body, &input); err != nil {")
        g.P("return nil, err")
        g.P("}")
        g.P("output, err := obj.", method.GoName, "(ctx, &input)")
        g.P("if err != nil {")
        g.P("return nil, err")
        g.P("}")
        g.P("bs, err := enc.Encode(output)")
        g.P("if err != nil {")
        g.P("return nil, err")
        g.P("}")
        g.P("return bs, nil")
    }
    g.P("default:")
    g.P("return nil, ", fmtPath.Ident("Errorf"), "(\"method %s not found\", req.Method)")
    g.P("}")
    g.P("}")
    g.P()
}

func generateClient(g *protogen.GeneratedFile, service *protogen.Service) {
    serviceName := upperFirstLatter(service.GoName)
    g.P("type ", serviceName, "Client struct {")
    g.P("client *", wrpcgoPackage.Ident("Client"))
    g.P("}")
    g.P()

    g.P("func New", service.GoName, "Client(name string, opts ...", wrpcgoPackage.Ident("ClientOption"), ") *", serviceName, "Client {")
    g.P("return &", serviceName, "Client{client: ", wrpcgoPackage.Ident("NewClient"), "(name, opts...)}")
    g.P("}")
    g.P()

    for _, method := range service.Methods {
        g.P("func (client *", serviceName, "Client)", method.GoName, "(ctx ", contextPackage.Ident("Context"),
            ", req *", method.Input.GoIdent.GoName, ", opts ...map[string]string) (*", method.Output.GoIdent.GoName, ", error) {")
        g.P("bin, _ := ", protoPackage.Ident("Marshal"), "(req)")
        g.P("bs, err :=  client.client.Invoke(ctx, \"proto\", \"\", \"", method.GoName, "\", bin, opts...)")
        g.P("if err != nil {")
        g.P("return nil, err")
        g.P("}")
        g.P("resp := &", method.Output.GoIdent.GoName, "{}")
        g.P("if err := ", protoPackage.Ident("Unmarshal") ,"(bs, resp); err != nil {")
        g.P("return nil, err")
        g.P("}")
        g.P("return resp, nil")
        g.P("}")
        g.P()
        g.P("func (client *", serviceName, "Client)", method.GoName, "ORI(ctx ", contextPackage.Ident("Context"),
            ", addr string, req *", method.Input.GoIdent.GoName, ", opts ...map[string]string) (*", method.Output.GoIdent.GoName, ", error) {")
        g.P("bin, _ := ", protoPackage.Ident("Marshal"), "(req)")
        g.P("bs, err :=  client.client.Invoke(ctx, \"proto\", addr, \"", method.GoName, "\", bin, opts...)")
        g.P("if err != nil {")
        g.P("return nil, err")
        g.P("}")
        g.P("resp := &", method.Output.GoIdent.GoName, "{}")
        g.P("if err := ", protoPackage.Ident("Unmarshal") ,"(bs, resp); err != nil {")
        g.P("return nil, err")
        g.P("}")
        g.P("return resp, nil")
        g.P("}")
        g.P()
    }
}
