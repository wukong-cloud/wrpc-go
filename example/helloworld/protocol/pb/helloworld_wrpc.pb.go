// Code generated by protoc-gen-go-wrpc DO NOT EDIT.
// versions:
// - protoc-gen-go-wrpc v1.0.0
// - protoc             v3.12.2
// source: helloworld.proto

package pb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	wrpc_go "github.com/wukong-cloud/wrpc-go"
)

type HelloServer interface {
	SayHello(context.Context, *HelloReq) (*HelloResp, error)
}

type NopHelloServerImpl struct{}

func (_ *NopHelloServerImpl) SayHello(ctx context.Context, req *HelloReq) (*HelloResp, error) {
	return nil, fmt.Errorf("method SayHello not implemented")
}

func NewHelloServer(name string, impl HelloServer, opts ...wrpc_go.ServerOption) wrpc_go.Server {
	return wrpc_go.NewRPCServer(name, impl, HelloServerDispatcher, opts...)
}

func HelloServerDispatcher(ctx context.Context, impl interface{}, req *wrpc_go.Request, enc wrpc_go.Encoder) ([]byte, error) {
	obj, ok := impl.(HelloServer)
	if !ok {
		return nil, fmt.Errorf("method %s not found", req.Method)
	}
	_ = obj
	switch req.Method {
	case "SayHello":
		input := HelloReq{}
		if err := enc.Decode(req.Body, &input); err != nil {
			return nil, err
		}
		output, err := obj.SayHello(ctx, &input)
		if err != nil {
			return nil, err
		}
		bs, err := enc.Encode(output)
		if err != nil {
			return nil, err
		}
		return bs, nil
	default:
		return nil, fmt.Errorf("method %s not found", req.Method)
	}
}

type HelloClient struct {
	client *wrpc_go.Client
}

func NewHelloClient(name string, opts ...wrpc_go.ClientOption) *HelloClient {
	return &HelloClient{client: wrpc_go.NewClient(name, opts...)}
}

func (client *HelloClient) SayHello(ctx context.Context, req *HelloReq, opts ...map[string]string) (*HelloResp, error) {
	bin, err := proto.Marshal(req)
	if err != nil {
		return nil, err
	}
	bs, err := client.client.Invoke(ctx, "proto", "", "SayHello", bin, opts...)
	if err != nil {
		return nil, err
	}
	resp := &HelloResp{}
	if err := proto.Unmarshal(bs, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

func (client *HelloClient) SayHelloORI(ctx context.Context, addr string, req *HelloReq, opts ...map[string]string) (*HelloResp, error) {
	bin, err := proto.Marshal(req)
	if err != nil {
		return nil, err
	}
	bs, err := client.client.Invoke(ctx, "proto", addr, "SayHello", bin, opts...)
	if err != nil {
		return nil, err
	}
	resp := &HelloResp{}
	if err := proto.Unmarshal(bs, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

func (client *HelloClient) BroadcastSayHello(ctx context.Context, req *HelloReq, opts ...map[string]string) (map[string]*HelloResp, map[string]error) {
	var resps = make(map[string]*HelloResp)
	var errs = make(map[string]error)
	bin, err := proto.Marshal(req)
	if err != nil {
		errs["marshalErr"] = err
		return nil, errs
	}
	addrs := client.client.GetAllEndpoints()
	for _, addr := range addrs {
		bs, err := client.client.Invoke(ctx, "proto", addr, "SayHello", bin, opts...)
		if err != nil {
			errs[addr] = err
		} else {
			resp := &HelloResp{}
			if err := proto.Unmarshal(bs, resp); err != nil {
				errs[addr] = err
			} else {
				resps[addr] = resp
			}
		}
	}
	return resps, errs
}
